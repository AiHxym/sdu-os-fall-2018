{
  "code": [
    {
      "name": "BIOS",
      "content": ""
    },
    {
      "name": "bootsect.S",
      "content": "!\n! SYS_SIZE is the number of clicks (16 bytes) to be loaded.\n! 0x3000 is 0x30000 bytes = 196kB, more than enough for current\n! versions of linux\n!\n#include <linux/config.h>\nSYSSIZE = DEF_SYSSIZE\n!\n!\tbootsect.s\t\t(C) 1991 Linus Torvalds\n!\tmodified by Drew Eckhardt\n!\n! bootsect.s is loaded at 0x7c00 by the bios-startup routines, and moves\n! iself out of the way to address 0x90000, and jumps there.\n!\n! It then loads 'setup' directly after itself (0x90200), and the system\n! at 0x10000, using BIOS interrupts. \n!\n! NOTE! currently system is at most 8*65536 bytes long. This should be no\n! problem, even in the future. I want to keep it simple. This 512 kB\n! kernel size should be enough, especially as this doesn't contain the\n! buffer cache as in minix\n!\n! The loader has been made as simple as possible, and continuos\n! read errors will result in a unbreakable loop. Reboot by hand. It\n! loads pretty fast by getting whole sectors at a time whenever possible.\n\n.globl begtext, begdata, begbss, endtext, enddata, endbss\n.text\nbegtext:\n.data\nbegdata:\n.bss\nbegbss:\n.text\n\nSETUPLEN = 4\t\t\t\t! nr of setup-sectors\nBOOTSEG  = 0x07c0\t\t\t! original address of boot-sector\nINITSEG  = DEF_INITSEG\t\t\t! we move boot here - out of the way\nSETUPSEG = DEF_SETUPSEG\t\t\t! setup starts here\nSYSSEG   = DEF_SYSSEG\t\t\t! system loaded at 0x10000 (65536).\nENDSEG   = SYSSEG + SYSSIZE\t\t! where to stop loading\n\n! ROOT_DEV & SWAP_DEV are now written by \"build\".\nROOT_DEV = 0\nSWAP_DEV = 0\n\nentry start\nstart:\n\tmov\tax,#BOOTSEG\n\tmov\tds,ax\n\tmov\tax,#INITSEG\n\tmov\tes,ax\n\tmov\tcx,#256\n\tsub\tsi,si\n\tsub\tdi,di\n\trep\n\tmovw\n\tjmpi\tgo,INITSEG\n\ngo:\tmov\tax,cs\t\t\n\tmov\tdx,#0xfef4\t! arbitrary value >>512 - disk parm size\n\n\tmov\tds,ax\n\tmov\tes,ax\n\tpush\tax\n\n\tmov\tss,ax\t\t! put stack at 0x9ff00 - 12.\n\tmov\tsp,dx\n/*\n *\tMany BIOS's default disk parameter tables will not \n *\trecognize multi-sector reads beyond the maximum sector number\n *\tspecified in the default diskette parameter tables - this may\n *\tmean 7 sectors in some cases.\n *\n *\tSince single sector reads are slow and out of the question,\n *\twe must take care of this by creating new parameter tables\n *\t(for the first disk) in RAM.  We will set the maximum sector\n *\tcount to 18 - the most we will encounter on an HD 1.44.  \n *\n *\tHigh doesn't hurt.  Low does.\n *\n *\tSegments are as follows: ds=es=ss=cs - INITSEG,\n *\t\tfs = 0, gs = parameter table segment\n */\n\n\n\tpush\t#0\n\tpop\tfs\n\tmov\tbx,#0x78\t\t! fs:bx is parameter table address\n\tseg fs\n\tlgs\tsi,(bx)\t\t\t! gs:si is source\n\n\tmov\tdi,dx\t\t\t! es:di is destination\n\tmov\tcx,#6\t\t\t! copy 12 bytes\n\tcld\n\n\trep\n\tseg gs\n\tmovw\n\n\tmov\tdi,dx\n\tmovb\t4(di),*18\t\t! patch sector count\n\n\tseg fs\n\tmov\t(bx),di\n\tseg fs\n\tmov\t2(bx),es\n\n\tpop\tax\n\tmov\tfs,ax\n\tmov\tgs,ax\n\t\n\txor\tah,ah\t\t\t! reset FDC \n\txor\tdl,dl\n\tint \t0x13\t\n\n! load the setup-sectors directly after the bootblock.\n! Note that 'es' is already set up.\n\nload_setup:\n\txor\tdx, dx\t\t\t! drive 0, head 0\n\tmov\tcx,#0x0002\t\t! sector 2, track 0\n\tmov\tbx,#0x0200\t\t! address = 512, in INITSEG\n\tmov\tax,#0x0200+SETUPLEN\t! service 2, nr of sectors\n\tint\t0x13\t\t\t! read it\n\tjnc\tok_load_setup\t\t! ok - continue\n\n\tpush\tax\t\t\t! dump error code\n\tcall\tprint_nl\n\tmov\tbp, sp\n\tcall\tprint_hex\n\tpop\tax\t\n\t\n\txor\tdl, dl\t\t\t! reset FDC\n\txor\tah, ah\n\tint\t0x13\n\tj\tload_setup\n\nok_load_setup:\n\n! Get disk drive parameters, specifically nr of sectors/track\n\n\txor\tdl,dl\n\tmov\tah,#0x08\t\t! AH=8 is get drive parameters\n\tint\t0x13\n\txor\tch,ch\n\tseg cs\n\tmov\tsectors,cx\n\tmov\tax,#INITSEG\n\tmov\tes,ax\n\n! Print some inane message\n\n\tmov\tah,#0x03\t\t! read cursor pos\n\txor\tbh,bh\n\tint\t0x10\n\t\n\tmov\tcx,#9\n\tmov\tbx,#0x0007\t\t! page 0, attribute 7 (normal)\n\tmov\tbp,#msg1\n\tmov\tax,#0x1301\t\t! write string, move cursor\n\tint\t0x10\n\n! ok, we've written the message, now\n! we want to load the system (at 0x10000)\n\n\tmov\tax,#SYSSEG\n\tmov\tes,ax\t\t! segment of 0x010000\n\tcall\tread_it\n\tcall\tkill_motor\n\tcall\tprint_nl\n\n! After that we check which root-device to use. If the device is\n! defined (!= 0), nothing is done and the given device is used.\n! Otherwise, either /dev/PS0 (2,28) or /dev/at0 (2,8), depending\n! on the number of sectors that the BIOS reports currently.\n\n\tseg cs\n\tmov\tax,root_dev\n\tor\tax,ax\n\tjne\troot_defined\n\tseg cs\n\tmov\tbx,sectors\n\tmov\tax,#0x0208\t\t! /dev/ps0 - 1.2Mb\n\tcmp\tbx,#15\n\tje\troot_defined\n\tmov\tax,#0x021c\t\t! /dev/PS0 - 1.44Mb\n\tcmp\tbx,#18\n\tje\troot_defined\nundef_root:\n\tjmp undef_root\nroot_defined:\n\tseg cs\n\tmov\troot_dev,ax\n\n! after that (everyting loaded), we jump to\n! the setup-routine loaded directly after\n! the bootblock:\n\n\tjmpi\t0,SETUPSEG\n\n! This routine loads the system at address 0x10000, making sure\n! no 64kB boundaries are crossed. We try to load it as fast as\n! possible, loading whole tracks whenever we can.\n!\n! in:\tes - starting address segment (normally 0x1000)\n!\nsread:\t.word 1+SETUPLEN\t! sectors read of current track\nhead:\t.word 0\t\t\t! current head\ntrack:\t.word 0\t\t\t! current track\n\nread_it:\n\tmov ax,es\n\ttest ax,#0x0fff\ndie:\tjne die\t\t\t! es must be at 64kB boundary\n\txor bx,bx\t\t! bx is starting address within segment\nrp_read:\n\tmov ax,es\n\tcmp ax,#ENDSEG\t\t! have we loaded all yet?\n\tjb ok1_read\n\tret\nok1_read:\n\tseg cs\n\tmov ax,sectors\n\tsub ax,sread\n\tmov cx,ax\n\tshl cx,#9\n\tadd cx,bx\n\tjnc ok2_read\n\tje ok2_read\n\txor ax,ax\n\tsub ax,bx\n\tshr ax,#9\nok2_read:\n\tcall read_track\n\tmov cx,ax\n\tadd ax,sread\n\tseg cs\n\tcmp ax,sectors\n\tjne ok3_read\n\tmov ax,#1\n\tsub ax,head\n\tjne ok4_read\n\tinc track\nok4_read:\n\tmov head,ax\n\txor ax,ax\nok3_read:\n\tmov sread,ax\n\tshl cx,#9\n\tadd bx,cx\n\tjnc rp_read\n\tmov ax,es\n\tadd ah,#0x10\n\tmov es,ax\n\txor bx,bx\n\tjmp rp_read\n\nread_track:\n\tpusha\n\tpusha\t\n\tmov\tax, #0xe2e \t! loading... message 2e = .\n\tmov\tbx, #7\n \tint\t0x10\n\tpopa\t\t\n\n\tmov dx,track\n\tmov cx,sread\n\tinc cx\n\tmov ch,dl\n\tmov dx,head\n\tmov dh,dl\n\tand dx,#0x0100\n\tmov ah,#2\n\t\n\tpush\tdx\t\t\t\t! save for error dump\n\tpush\tcx\n\tpush\tbx\n\tpush\tax\n\n\tint 0x13\n\tjc bad_rt\n\tadd\tsp, #8   \t\n\tpopa\n\tret\n\nbad_rt:\tpush\tax\t\t\t\t! save error code\n\tcall\tprint_all\t\t\t! ah = error, al = read\n\t\n\t\n\txor ah,ah\n\txor dl,dl\n\tint 0x13\n\t\n\n\tadd\tsp, #10\n\tpopa\t\n\tjmp read_track\n\n/*\n *\tprint_all is for debugging purposes.  \n *\tIt will print out all of the registers.  The assumption is that this is\n *\tcalled from a routine, with a stack frame like\n *\tdx \n *\tcx\n *\tbx\n *\tax\n *\terror\n *\tret <- sp\n *\n*/\n \nprint_all:\n\tmov\tcx, #5\t\t! error code + 4 registers\n\tmov\tbp, sp\t\n\nprint_loop:\n\tpush\tcx\t\t! save count left\n\tcall\tprint_nl\t! nl for readability\n\tjae\tno_reg\t\t! see if register name is needed\n\t\n\tmov\tax, #0xe05 + 0x41 - 1\n\tsub\tal, cl\n\tint\t0x10\n\n\tmov\tal, #0x58 \t! X\n\tint\t0x10\n\n\tmov\tal, #0x3a \t! :\n\tint\t0x10\n\nno_reg:\n\tadd\tbp, #2\t\t! next register\n\tcall\tprint_hex\t! print it\n\tpop\tcx\n\tloop\tprint_loop\n\tret\n\nprint_nl:\n\tmov\tax, #0xe0d\t! CR\n\tint\t0x10\n\tmov\tal, #0xa\t! LF\n\tint \t0x10\n\tret\n\n/*\n *\tprint_hex is for debugging purposes, and prints the word\n *\tpointed to by ss:bp in hexadecmial.\n*/\n\nprint_hex:\n\tmov\tcx, #4\t\t! 4 hex digits\n\tmov\tdx, (bp)\t! load word into dx\nprint_digit:\n\trol\tdx, #4\t\t! rotate so that lowest 4 bits are used\n\tmov\tah, #0xe\t\n\tmov\tal, dl\t\t! mask off so we have only next nibble\n\tand\tal, #0xf\n\tadd\tal, #0x30\t! convert to 0 based digit, '0'\n\tcmp\tal, #0x39\t! check for overflow\n\tjbe\tgood_digit\n\tadd\tal, #0x41 - 0x30 - 0xa \t! 'A' - '0' - 0xa\n\ngood_digit:\n\tint\t0x10\n\tloop\tprint_digit\n\tret\n\n\n/*\n * This procedure turns off the floppy drive motor, so\n * that we enter the kernel in a known state, and\n * don't have to worry about it later.\n */\nkill_motor:\n\tpush dx\n\tmov dx,#0x3f2\n\txor al, al\n\toutb\n\tpop dx\n\tret\n\nsectors:\n\t.word 0\n\nmsg1:\n\t.byte 13,10\n\t.ascii \"Loading\"\n\n.org 506\nswap_dev:\n\t.word SWAP_DEV\nroot_dev:\n\t.word ROOT_DEV\nboot_flag:\n\t.word 0xAA55\n\n.text\nendtext:\n.data\nenddata:\n.bss\nendbss:\n\n"
    },
    {
      "name": "setup.S",
      "content": "!\n!\tsetup.s\t\t(C) 1991 Linus Torvalds\n!\n! setup.s is responsible for getting the system data from the BIOS,\n! and putting them into the appropriate places in system memory.\n! both setup.s and system has been loaded by the bootblock.\n!\n! This code asks the bios for memory/disk/other parameters, and\n! puts them in a \"safe\" place: 0x90000-0x901FF, ie where the\n! boot-block used to be. It is then up to the protected mode\n! system to read them from there before the area is overwritten\n! for buffer-blocks.\n!\n\n! NOTE! These had better be the same as in bootsect.s!\n#include <linux/config.h>\n\nINITSEG  = DEF_INITSEG\t! we move boot here - out of the way\nSYSSEG   = DEF_SYSSEG\t! system loaded at 0x10000 (65536).\nSETUPSEG = DEF_SETUPSEG\t! this is the current segment\n\n.globl begtext, begdata, begbss, endtext, enddata, endbss\n.text\nbegtext:\n.data\nbegdata:\n.bss\nbegbss:\n.text\n\nentry start\nstart:\n\n! ok, the read went well so we get current cursor position and save it for\n! posterity.\n\n\tmov\tax,#INITSEG\t! this is done in bootsect already, but...\n\tmov\tds,ax\n\n! Get memory size (extended mem, kB)\n\n\tmov\tah,#0x88\n\tint\t0x15\n\tmov\t[2],ax\n\n! check for EGA/VGA and some config parameters\n\n\tmov\tah,#0x12\n\tmov\tbl,#0x10\n\tint\t0x10\n\tmov\t[8],ax\n\tmov\t[10],bx\n\tmov\t[12],cx\n\tmov\tax,#0x5019\n\tcmp\tbl,#0x10\n\tje\tnovga\n\tcall\tchsvga\nnovga:\tmov\t[14],ax\n\tmov\tah,#0x03\t! read cursor pos\n\txor\tbh,bh\n\tint\t0x10\t\t! save it in known place, con_init fetches\n\tmov\t[0],dx\t\t! it from 0x90000.\n\t\n! Get video-card data:\n\t\n\tmov\tah,#0x0f\n\tint\t0x10\n\tmov\t[4],bx\t\t! bh = display page\n\tmov\t[6],ax\t\t! al = video mode, ah = window width\n\n! Get hd0 data\n\n\tmov\tax,#0x0000\n\tmov\tds,ax\n\tlds\tsi,[4*0x41]\n\tmov\tax,#INITSEG\n\tmov\tes,ax\n\tmov\tdi,#0x0080\n\tmov\tcx,#0x10\n\trep\n\tmovsb\n\n! Get hd1 data\n\n\tmov\tax,#0x0000\n\tmov\tds,ax\n\tlds\tsi,[4*0x46]\n\tmov\tax,#INITSEG\n\tmov\tes,ax\n\tmov\tdi,#0x0090\n\tmov\tcx,#0x10\n\trep\n\tmovsb\n\n! Check that there IS a hd1 :-)\n\n\tmov\tax,#0x01500\n\tmov\tdl,#0x81\n\tint\t0x13\n\tjc\tno_disk1\n\tcmp\tah,#3\n\tje\tis_disk1\nno_disk1:\n\tmov\tax,#INITSEG\n\tmov\tes,ax\n\tmov\tdi,#0x0090\n\tmov\tcx,#0x10\n\tmov\tax,#0x00\n\trep\n\tstosb\nis_disk1:\n\n! now we want to move to protected mode ...\n\n\tcli\t\t\t! no interrupts allowed !\n\n! first we move the system to it's rightful place\n\n\tmov\tax,#0x0000\n\tcld\t\t\t! 'direction'=0, movs moves forward\ndo_move:\n\tmov\tes,ax\t\t! destination segment\n\tadd\tax,#0x1000\n\tcmp\tax,#0x9000\n\tjz\tend_move\n\tmov\tds,ax\t\t! source segment\n\tsub\tdi,di\n\tsub\tsi,si\n\tmov \tcx,#0x8000\n\trep\n\tmovsw\n\tjmp\tdo_move\n\n! then we load the segment descriptors\n\nend_move:\n\tmov\tax,#SETUPSEG\t! right, forgot this at first. didn't work :-)\n\tmov\tds,ax\n\tlidt\tidt_48\t\t! load idt with 0,0\n\tlgdt\tgdt_48\t\t! load gdt with whatever appropriate\n\n! that was painless, now we enable A20\n\n\tcall\tempty_8042\n\tmov\tal,#0xD1\t\t! command write\n\tout\t#0x64,al\n\tcall\tempty_8042\n\tmov\tal,#0xDF\t\t! A20 on\n\tout\t#0x60,al\n\tcall\tempty_8042\n\n! well, that went ok, I hope. Now we have to reprogram the interrupts :-(\n! we put them right after the intel-reserved hardware interrupts, at\n! int 0x20-0x2F. There they won't mess up anything. Sadly IBM really\n! messed this up with the original PC, and they haven't been able to\n! rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,\n! which is used for the internal hardware interrupts as well. We just\n! have to reprogram the 8259's, and it isn't fun.\n\n\tmov\tal,#0x11\t\t! initialization sequence\n\tout\t#0x20,al\t\t! send it to 8259A-1\n\t.word\t0x00eb,0x00eb\t\t! jmp $+2, jmp $+2\n\tout\t#0xA0,al\t\t! and to 8259A-2\n\t.word\t0x00eb,0x00eb\n\tmov\tal,#0x20\t\t! start of hardware int's (0x20)\n\tout\t#0x21,al\n\t.word\t0x00eb,0x00eb\n\tmov\tal,#0x28\t\t! start of hardware int's 2 (0x28)\n\tout\t#0xA1,al\n\t.word\t0x00eb,0x00eb\n\tmov\tal,#0x04\t\t! 8259-1 is master\n\tout\t#0x21,al\n\t.word\t0x00eb,0x00eb\n\tmov\tal,#0x02\t\t! 8259-2 is slave\n\tout\t#0xA1,al\n\t.word\t0x00eb,0x00eb\n\tmov\tal,#0x01\t\t! 8086 mode for both\n\tout\t#0x21,al\n\t.word\t0x00eb,0x00eb\n\tout\t#0xA1,al\n\t.word\t0x00eb,0x00eb\n\tmov\tal,#0xFF\t\t! mask off all interrupts for now\n\tout\t#0x21,al\n\t.word\t0x00eb,0x00eb\n\tout\t#0xA1,al\n\n! well, that certainly wasn't fun :-(. Hopefully it works, and we don't\n! need no steenking BIOS anyway (except for the initial loading :-).\n! The BIOS-routine wants lots of unnecessary data, and it's less\n! \"interesting\" anyway. This is how REAL programmers do it.\n!\n! Well, now's the time to actually move into protected mode. To make\n! things as simple as possible, we do no register set-up or anything,\n! we let the gnu-compiled 32-bit programs do that. We just jump to\n! absolute address 0x00000, in 32-bit protected mode.\n\n\tmov\tax,#0x0001\t! protected mode (PE) bit\n\tlmsw\tax\t\t! This is it!\n\tjmpi\t0,8\t\t! jmp offset 0 of segment 8 (cs)\n\n! This routine checks that the keyboard command queue is empty\n! No timeout is used - if this hangs there is something wrong with\n! the machine, and we probably couldn't proceed anyway.\nempty_8042:\n\t.word\t0x00eb,0x00eb\n\tin\tal,#0x64\t! 8042 status port\n\ttest\tal,#2\t\t! is input buffer full?\n\tjnz\tempty_8042\t! yes - loop\n\tret\n\n! Routine trying to recognize type of SVGA-board present (if any)\n! and if it recognize one gives the choices of resolution it offers.\n! If one is found the resolution chosen is given by al,ah (rows,cols).\n\nchsvga:\tcld\n\tpush\tds\n\tpush\tcs\n\tpop\tds\n\tmov \tax,#0xc000\n\tmov\tes,ax\n\tlea\tsi,msg1\n\tcall\tprtstr\nnokey:\tin\tal,#0x60\n\tcmp\tal,#0x82\n\tjb\tnokey\n\tcmp\tal,#0xe0\n\tja\tnokey\n\tcmp\tal,#0x9c\n\tje\tsvga\n\tmov\tax,#0x5019\n\tpop\tds\n\tret\nsvga:\tlea \tsi,idati\t\t! Check ATI 'clues'\n\tmov\tdi,#0x31\n\tmov \tcx,#0x09\n\trepe\n\tcmpsb\n\tjne\tnoati\n\tlea\tsi,dscati\n\tlea\tdi,moati\n\tlea\tcx,selmod\n\tjmp\tcx\nnoati:\tmov\tax,#0x200f\t\t! Check Ahead 'clues'\n\tmov\tdx,#0x3ce\n\tout\tdx,ax\n\tinc\tdx\n\tin\tal,dx\n\tcmp\tal,#0x20\n\tje\tisahed\n\tcmp\tal,#0x21\n\tjne\tnoahed\nisahed:\tlea\tsi,dscahead\n\tlea\tdi,moahead\n\tlea\tcx,selmod\n\tjmp\tcx\nnoahed:\tmov\tdx,#0x3c3\t\t! Check Chips & Tech. 'clues'\n\tin\tal,dx\n\tor\tal,#0x10\n\tout\tdx,al\n\tmov\tdx,#0x104\t\t\n\tin\tal,dx\n\tmov\tbl,al\n\tmov\tdx,#0x3c3\n\tin\tal,dx\n\tand\tal,#0xef\n\tout\tdx,al\n\tcmp\tbl,[idcandt]\n\tjne\tnocant\n\tlea\tsi,dsccandt\n\tlea\tdi,mocandt\n\tlea\tcx,selmod\n\tjmp\tcx\nnocant:\tmov\tdx,#0x3d4\t\t! Check Cirrus 'clues'\n\tmov\tal,#0x0c\n\tout\tdx,al\n\tinc\tdx\n\tin\tal,dx\n\tmov\tbl,al\n\txor\tal,al\n\tout\tdx,al\n\tdec\tdx\n\tmov\tal,#0x1f\n\tout\tdx,al\n\tinc\tdx\n\tin\tal,dx\n\tmov\tbh,al\n\txor\tah,ah\n\tshl\tal,#4\n\tmov\tcx,ax\n\tmov\tal,bh\n\tshr\tal,#4\n\tadd\tcx,ax\n\tshl\tcx,#8\n\tadd\tcx,#6\n\tmov\tax,cx\n\tmov\tdx,#0x3c4\n\tout\tdx,ax\n\tinc\tdx\n\tin\tal,dx\n\tand\tal,al\n\tjnz\tnocirr\n\tmov\tal,bh\n\tout\tdx,al\n\tin\tal,dx\n\tcmp\tal,#0x01\n\tjne\tnocirr\n\tcall\trst3d4\t\n\tlea\tsi,dsccirrus\n\tlea\tdi,mocirrus\n\tlea\tcx,selmod\n\tjmp\tcx\nrst3d4:\tmov\tdx,#0x3d4\n\tmov\tal,bl\n\txor\tah,ah\n\tshl\tax,#8\n\tadd\tax,#0x0c\n\tout\tdx,ax\n\tret\t\nnocirr:\tcall\trst3d4\t\t\t! Check Everex 'clues'\n\tmov\tax,#0x7000\n\txor\tbx,bx\n\tint\t0x10\n\tcmp\tal,#0x70\n\tjne\tnoevrx\n\tshr\tdx,#4\n\tcmp\tdx,#0x678\n\tje\tistrid\n\tcmp\tdx,#0x236\n\tje\tistrid\n\tlea\tsi,dsceverex\n\tlea\tdi,moeverex\n\tlea\tcx,selmod\n\tjmp\tcx\nistrid:\tlea\tcx,ev2tri\n\tjmp\tcx\nnoevrx:\tlea\tsi,idgenoa\t\t! Check Genoa 'clues'\n\txor \tax,ax\n\tseg es\n\tmov\tal,[0x37]\n\tmov\tdi,ax\n\tmov\tcx,#0x04\n\tdec\tsi\n\tdec\tdi\nl1:\tinc\tsi\n\tinc\tdi\n\tmov\tal,(si)\n\tseg es\n\tand\tal,(di)\n\tcmp\tal,(si)\n\tloope \tl1\n\tcmp\tcx,#0x00\n\tjne\tnogen\n\tlea\tsi,dscgenoa\n\tlea\tdi,mogenoa\n\tlea\tcx,selmod\n\tjmp\tcx\nnogen:\tlea\tsi,idparadise\t\t! Check Paradise 'clues'\n\tmov\tdi,#0x7d\n\tmov\tcx,#0x04\n\trepe\n\tcmpsb\n\tjne\tnopara\n\tlea\tsi,dscparadise\n\tlea\tdi,moparadise\n\tlea\tcx,selmod\n\tjmp\tcx\nnopara:\tmov\tdx,#0x3c4\t\t! Check Trident 'clues'\n\tmov\tal,#0x0e\n\tout\tdx,al\n\tinc\tdx\n\tin\tal,dx\n\txchg\tah,al\n\tmov\tal,#0x00\n\tout\tdx,al\n\tin\tal,dx\n\txchg\tal,ah\n\tmov\tbl,al\t\t! Strange thing ... in the book this wasn't\n\tand\tbl,#0x02\t! necessary but it worked on my card which\n\tjz\tsetb2\t\t! is a trident. Without it the screen goes\n\tand\tal,#0xfd\t! blurred ...\n\tjmp\tclrb2\t\t!\nsetb2:\tor\tal,#0x02\t!\nclrb2:\tout\tdx,al\n\tand\tah,#0x0f\n\tcmp\tah,#0x02\n\tjne\tnotrid\nev2tri:\tlea\tsi,dsctrident\n\tlea\tdi,motrident\n\tlea\tcx,selmod\n\tjmp\tcx\nnotrid:\tmov\tdx,#0x3cd\t\t! Check Tseng 'clues'\n\tin\tal,dx\t\t\t! Could things be this simple ! :-)\n\tmov\tbl,al\n\tmov\tal,#0x55\n\tout\tdx,al\n\tin\tal,dx\n\tmov\tah,al\n\tmov\tal,bl\n\tout\tdx,al\n\tcmp\tah,#0x55\n \tjne\tnotsen\n\tlea\tsi,dsctseng\n\tlea\tdi,motseng\n\tlea\tcx,selmod\n\tjmp\tcx\nnotsen:\tmov\tdx,#0x3cc\t\t! Check Video7 'clues'\n\tin\tal,dx\n\tmov\tdx,#0x3b4\n\tand\tal,#0x01\n\tjz\teven7\n\tmov\tdx,#0x3d4\neven7:\tmov\tal,#0x0c\n\tout\tdx,al\n\tinc\tdx\n\tin\tal,dx\n\tmov\tbl,al\n\tmov\tal,#0x55\n\tout\tdx,al\n\tin\tal,dx\n\tdec\tdx\n\tmov\tal,#0x1f\n\tout\tdx,al\n\tinc\tdx\n\tin\tal,dx\n\tmov\tbh,al\n\tdec\tdx\n\tmov\tal,#0x0c\n\tout\tdx,al\n\tinc\tdx\n\tmov\tal,bl\n\tout\tdx,al\n\tmov\tal,#0x55\n\txor\tal,#0xea\n\tcmp\tal,bh\n\tjne\tnovid7\n\tlea\tsi,dscvideo7\n\tlea\tdi,movideo7\nselmod:\tpush\tsi\n\tlea\tsi,msg2\n\tcall\tprtstr\n\txor\tcx,cx\n\tmov\tcl,(di)\n\tpop\tsi\n\tpush\tsi\n\tpush\tcx\ntbl:\tpop\tbx\n\tpush\tbx\n\tmov\tal,bl\n\tsub\tal,cl\n\tcall\tdprnt\n\tcall\tspcing\n\tlodsw\n\txchg\tal,ah\n\tcall\tdprnt\n\txchg\tah,al\n\tpush\tax\n\tmov\tal,#0x78\n\tcall\tprnt1\n\tpop\tax\n\tcall\tdprnt\n\tcall\tdocr\n\tloop\ttbl\n\tpop\tcx\n\tcall\tdocr\n\tlea\tsi,msg3\n\tcall\tprtstr\n\tpop\tsi\n\tadd\tcl,#0x80\nnonum:\tin\tal,#0x60\t! Quick and dirty...\n\tcmp\tal,#0x82\n\tjb\tnonum\n\tcmp\tal,#0x8b\n\tje\tzero\n\tcmp\tal,cl\n\tja\tnonum\n\tjmp\tnozero\nzero:\tsub\tal,#0x0a\nnozero:\tsub\tal,#0x80\n\tdec\tal\n\txor\tah,ah\n\tadd\tdi,ax\n\tinc\tdi\n\tpush\tax\n\tmov\tal,(di)\n\tint \t0x10\n\tpop\tax\n\tshl\tax,#1\n\tadd\tsi,ax\n\tlodsw\n\tpop\tds\n\tret\nnovid7:\tpop\tds\t! Here could be code to support standard 80x50,80x30\n\tmov\tax,#0x5019\t\n\tret\n\n! Routine that 'tabs' to next col.\n\nspcing:\tmov\tal,#0x2e\n\tcall\tprnt1\n\tmov\tal,#0x20\n\tcall\tprnt1\t\n\tmov\tal,#0x20\n\tcall\tprnt1\t\n\tmov\tal,#0x20\n\tcall\tprnt1\t\n\tmov\tal,#0x20\n\tcall\tprnt1\n\tret\t\n\n! Routine to print asciiz-string at DS:SI\n\nprtstr:\tlodsb\n\tand\tal,al\n\tjz\tfin\n\tcall\tprnt1\n\tjmp\tprtstr\nfin:\tret\n\n! Routine to print a decimal value on screen, the value to be\n! printed is put in al (i.e 0-255). \n\ndprnt:\tpush\tax\n\tpush\tcx\n\tmov\tah,#0x00\t\t\n\tmov\tcl,#0x0a\n\tidiv\tcl\n\tcmp\tal,#0x09\n\tjbe\tlt100\n\tcall\tdprnt\n\tjmp\tskip10\nlt100:\tadd\tal,#0x30\n\tcall\tprnt1\nskip10:\tmov\tal,ah\n\tadd\tal,#0x30\n\tcall\tprnt1\t\n\tpop\tcx\n\tpop\tax\n\tret\n\n! Part of above routine, this one just prints ascii al\n\nprnt1:\tpush\tax\n\tpush\tcx\n\tmov\tbh,#0x00\n\tmov\tcx,#0x01\n\tmov\tah,#0x0e\n\tint\t0x10\n\tpop\tcx\n\tpop\tax\n\tret\n\n! Prints <CR> + <LF>\n\ndocr:\tpush\tax\n\tpush\tcx\n\tmov\tbh,#0x00\n\tmov\tah,#0x0e\n\tmov\tal,#0x0a\n\tmov\tcx,#0x01\n\tint\t0x10\n\tmov\tal,#0x0d\n\tint\t0x10\n\tpop\tcx\n\tpop\tax\n\tret\t\n\t\ngdt:\n\t.word\t0,0,0,0\t\t! dummy\n\n\t.word\t0x07FF\t\t! 8Mb - limit=2047 (2048*4096=8Mb)\n\t.word\t0x0000\t\t! base address=0\n\t.word\t0x9A00\t\t! code read/exec\n\t.word\t0x00C0\t\t! granularity=4096, 386\n\n\t.word\t0x07FF\t\t! 8Mb - limit=2047 (2048*4096=8Mb)\n\t.word\t0x0000\t\t! base address=0\n\t.word\t0x9200\t\t! data read/write\n\t.word\t0x00C0\t\t! granularity=4096, 386\n\nidt_48:\n\t.word\t0\t\t\t! idt limit=0\n\t.word\t0,0\t\t\t! idt base=0L\n\ngdt_48:\n\t.word\t0x800\t\t! gdt limit=2048, 256 GDT entries\n\t.word\t512+gdt,0x9\t! gdt base = 0X9xxxx\n\nmsg1:\t\t.ascii\t\"Press <RETURN> to see SVGA-modes available or any other key to continue.\"\n\t\tdb\t0x0d, 0x0a, 0x0a, 0x00\nmsg2:\t\t.ascii\t\"Mode:  COLSxROWS:\"\n\t\tdb\t0x0d, 0x0a, 0x0a, 0x00\nmsg3:\t\t.ascii\t\"Choose mode by pressing the corresponding number.\"\n\t\tdb\t0x0d, 0x0a, 0x00\n\t\t\nidati:\t\t.ascii\t\"761295520\"\nidcandt:\t.byte\t0xa5\nidgenoa:\t.byte\t0x77, 0x00, 0x66, 0x99\nidparadise:\t.ascii\t\"VGA=\"\n\n! Manufacturer:\t  Numofmodes:\tMode:\n\nmoati:\t\t.byte\t0x02,\t0x23, 0x33 \nmoahead:\t.byte\t0x05,\t0x22, 0x23, 0x24, 0x2f, 0x34\nmocandt:\t.byte\t0x02,\t0x60, 0x61\nmocirrus:\t.byte\t0x04,\t0x1f, 0x20, 0x22, 0x31\nmoeverex:\t.byte\t0x0a,\t0x03, 0x04, 0x07, 0x08, 0x0a, 0x0b, 0x16, 0x18, 0x21, 0x40\nmogenoa:\t.byte\t0x0a,\t0x58, 0x5a, 0x60, 0x61, 0x62, 0x63, 0x64, 0x72, 0x74, 0x78\nmoparadise:\t.byte\t0x02,\t0x55, 0x54\nmotrident:\t.byte\t0x07,\t0x50, 0x51, 0x52, 0x57, 0x58, 0x59, 0x5a\nmotseng:\t.byte\t0x05,\t0x26, 0x2a, 0x23, 0x24, 0x22\nmovideo7:\t.byte\t0x06,\t0x40, 0x43, 0x44, 0x41, 0x42, 0x45\n\n!\t\t\tmsb = Cols lsb = Rows:\n\ndscati:\t\t.word\t0x8419, 0x842c\ndscahead:\t.word\t0x842c, 0x8419, 0x841c, 0xa032, 0x5042\ndsccandt:\t.word\t0x8419, 0x8432\ndsccirrus:\t.word\t0x8419, 0x842c, 0x841e, 0x6425\ndsceverex:\t.word\t0x5022, 0x503c, 0x642b, 0x644b, 0x8419, 0x842c, 0x501e, 0x641b, 0xa040, 0x841e\ndscgenoa:\t.word\t0x5020, 0x642a, 0x8419, 0x841d, 0x8420, 0x842c, 0x843c, 0x503c, 0x5042, 0x644b\ndscparadise:\t.word\t0x8419, 0x842b\ndsctrident:\t.word \t0x501e, 0x502b, 0x503c, 0x8419, 0x841e, 0x842b, 0x843c\ndsctseng:\t.word\t0x503c, 0x6428, 0x8419, 0x841c, 0x842c\ndscvideo7:\t.word\t0x502b, 0x503c, 0x643c, 0x8419, 0x842c, 0x841c\n\t\n.text\nendtext:\n.data\nenddata:\n.bss\nendbss:\n"
    },
    {
      "name": "head.S",
      "content": "/*\n *  linux/boot/head.s\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n *  head.s contains the 32-bit startup code.\n *\n * NOTE!!! Startup happens at absolute address 0x00000000, which is also where\n * the page directory will exist. The startup code will be overwritten by\n * the page directory.\n */\n.text\n.globl _idt,_gdt,_pg_dir,_tmp_floppy_area\n_pg_dir:\nstartup_32:\n\tmovl $0x10,%eax\n\tmov %ax,%ds\n\tmov %ax,%es\n\tmov %ax,%fs\n\tmov %ax,%gs\n\tlss _stack_start,%esp\n\tcall setup_idt\n\tcall setup_gdt\n\tmovl $0x10,%eax\t\t# reload all the segment registers\n\tmov %ax,%ds\t\t# after changing gdt. CS was already\n\tmov %ax,%es\t\t# reloaded in 'setup_gdt'\n\tmov %ax,%fs\n\tmov %ax,%gs\n\tlss _stack_start,%esp\n\txorl %eax,%eax\n1:\tincl %eax\t\t# check that A20 really IS enabled\n\tmovl %eax,0x000000\t# loop forever if it isn't\n\tcmpl %eax,0x100000\n\tje 1b\n/*\n * NOTE! 486 should set bit 16, to check for write-protect in supervisor\n * mode. Then it would be unnecessary with the \"verify_area()\"-calls.\n * 486 users probably want to set the NE (#5) bit also, so as to use\n * int 16 for math errors.\n */\n\tmovl %cr0,%eax\t\t# check math chip\n\tandl $0x80000011,%eax\t# Save PG,PE,ET\n/* \"orl $0x10020,%eax\" here for 486 might be good */\n\torl $2,%eax\t\t# set MP\n\tmovl %eax,%cr0\n\tcall check_x87\n\tjmp after_page_tables\n\n/*\n * We depend on ET to be correct. This checks for 287/387.\n */\ncheck_x87:\n\tfninit\n\tfstsw %ax\n\tcmpb $0,%al\n\tje 1f\t\t\t/* no coprocessor: have to set bits */\n\tmovl %cr0,%eax\n\txorl $6,%eax\t\t/* reset MP, set EM */\n\tmovl %eax,%cr0\n\tret\n.align 2\n1:\t.byte 0xDB,0xE4\t\t/* fsetpm for 287, ignored by 387 */\n\tret\n\n/*\n *  setup_idt\n *\n *  sets up a idt with 256 entries pointing to\n *  ignore_int, interrupt gates. It then loads\n *  idt. Everything that wants to install itself\n *  in the idt-table may do so themselves. Interrupts\n *  are enabled elsewhere, when we can be relatively\n *  sure everything is ok. This routine will be over-\n *  written by the page tables.\n */\nsetup_idt:\n\tlea ignore_int,%edx\n\tmovl $0x00080000,%eax\n\tmovw %dx,%ax\t\t/* selector = 0x0008 = cs */\n\tmovw $0x8E00,%dx\t/* interrupt gate - dpl=0, present */\n\n\tlea _idt,%edi\n\tmov $256,%ecx\nrp_sidt:\n\tmovl %eax,(%edi)\n\tmovl %edx,4(%edi)\n\taddl $8,%edi\n\tdec %ecx\n\tjne rp_sidt\n\tlidt idt_descr\n\tret\n\n/*\n *  setup_gdt\n *\n *  This routines sets up a new gdt and loads it.\n *  Only two entries are currently built, the same\n *  ones that were built in init.s. The routine\n *  is VERY complicated at two whole lines, so this\n *  rather long comment is certainly needed :-).\n *  This routine will beoverwritten by the page tables.\n */\nsetup_gdt:\n\tlgdt gdt_descr\n\tret\n\n/*\n * I put the kernel page tables right after the page directory,\n * using 4 of them to span 16 Mb of physical memory. People with\n * more than 16MB will have to expand this.\n */\n.org 0x1000\npg0:\n\n.org 0x2000\npg1:\n\n.org 0x3000\npg2:\n\n.org 0x4000\npg3:\n\n.org 0x5000\n/*\n * tmp_floppy_area is used by the floppy-driver when DMA cannot\n * reach to a buffer-block. It needs to be aligned, so that it isn't\n * on a 64kB border.\n */\n_tmp_floppy_area:\n\t.fill 1024,1,0\n\nafter_page_tables:\n\tpushl $0\t\t# These are the parameters to main :-)\n\tpushl $0\n\tpushl $0\n\tpushl $L6\t\t# return address for main, if it decides to.\n\tpushl $_main\n\tjmp setup_paging\nL6:\n\tjmp L6\t\t\t# main should never return here, but\n\t\t\t\t# just in case, we know what happens.\n\n/* This is the default interrupt \"handler\" :-) */\nint_msg:\n\t.asciz \"Unknown interrupt\\n\\r\"\n.align 2\nignore_int:\n\tpushl %eax\n\tpushl %ecx\n\tpushl %edx\n\tpush %ds\n\tpush %es\n\tpush %fs\n\tmovl $0x10,%eax\n\tmov %ax,%ds\n\tmov %ax,%es\n\tmov %ax,%fs\n\tpushl $int_msg\n\tcall _printk\n\tpopl %eax\n\tpop %fs\n\tpop %es\n\tpop %ds\n\tpopl %edx\n\tpopl %ecx\n\tpopl %eax\n\tiret\n\n\n/*\n * Setup_paging\n *\n * This routine sets up paging by setting the page bit\n * in cr0. The page tables are set up, identity-mapping\n * the first 16MB. The pager assumes that no illegal\n * addresses are produced (ie >4Mb on a 4Mb machine).\n *\n * NOTE! Although all physical memory should be identity\n * mapped by this routine, only the kernel page functions\n * use the >1Mb addresses directly. All \"normal\" functions\n * use just the lower 1Mb, or the local data space, which\n * will be mapped to some other place - mm keeps track of\n * that.\n *\n * For those with more memory than 16 Mb - tough luck. I've\n * not got it, why should you :-) The source is here. Change\n * it. (Seriously - it shouldn't be too difficult. Mostly\n * change some constants etc. I left it at 16Mb, as my machine\n * even cannot be extended past that (ok, but it was cheap :-)\n * I've tried to show which constants to change by having\n * some kind of marker at them (search for \"16Mb\"), but I\n * won't guarantee that's all :-( )\n */\n.align 2\nsetup_paging:\n\tmovl $1024*5,%ecx\t\t/* 5 pages - pg_dir+4 page tables */\n\txorl %eax,%eax\n\txorl %edi,%edi\t\t\t/* pg_dir is at 0x000 */\n\tcld;rep;stosl\n\tmovl $pg0+7,_pg_dir\t\t/* set present bit/user r/w */\n\tmovl $pg1+7,_pg_dir+4\t\t/*  --------- \" \" --------- */\n\tmovl $pg2+7,_pg_dir+8\t\t/*  --------- \" \" --------- */\n\tmovl $pg3+7,_pg_dir+12\t\t/*  --------- \" \" --------- */\n\tmovl $pg3+4092,%edi\n\tmovl $0xfff007,%eax\t\t/*  16Mb - 4096 + 7 (r/w user,p) */\n\tstd\n1:\tstosl\t\t\t/* fill pages backwards - more efficient :-) */\n\tsubl $0x1000,%eax\n\tjge 1b\n\txorl %eax,%eax\t\t/* pg_dir is at 0x0000 */\n\tmovl %eax,%cr3\t\t/* cr3 - page directory start */\n\tmovl %cr0,%eax\n\torl $0x80000000,%eax\n\tmovl %eax,%cr0\t\t/* set paging (PG) bit */\n\tret\t\t\t/* this also flushes prefetch-queue */\n\n.align 2\n.word 0\nidt_descr:\n\t.word 256*8-1\t\t# idt contains 256 entries\n\t.long _idt\n.align 2\n.word 0\ngdt_descr:\n\t.word 256*8-1\t\t# so does gdt (not that that's any\n\t.long _gdt\t\t# magic number, but it works for me :^)\n\n\t.align 3\n_idt:\t.fill 256,8,0\t\t# idt is uninitialized\n\n_gdt:\t.quad 0x0000000000000000\t/* NULL descriptor */\n\t.quad 0x00c09a0000000fff\t/* 16Mb */\n\t.quad 0x00c0920000000fff\t/* 16Mb */\n\t.quad 0x0000000000000000\t/* TEMPORARY - don't use */\n\t.fill 252,8,0\t\t\t/* space for LDT's and TSS's etc */\n"
    },
    {
      "name": "main.c",
      "content": "/*\n *  linux/init/main.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#define __LIBRARY__\n#include <unistd.h>\n#include <time.h>\n\n/*\n * we need this inline - forking from kernel space will result\n * in NO COPY ON WRITE (!!!), until an execve is executed. This\n * is no problem, but for the stack. This is handled by not letting\n * main() use the stack at all after fork(). Thus, no function\n * calls - which means inline code for fork too, as otherwise we\n * would use the stack upon exit from 'fork()'.\n *\n * Actually only pause and fork are needed inline, so that there\n * won't be any messing with the stack from main(), but we define\n * some others too.\n */\nstatic inline _syscall0(int,fork)\nstatic inline _syscall0(int,pause)\nstatic inline _syscall1(int,setup,void *,BIOS)\nstatic inline _syscall0(int,sync)\n\n#include <linux/tty.h>\n#include <linux/sched.h>\n#include <linux/head.h>\n#include <asm/system.h>\n#include <asm/io.h>\n\n#include <stddef.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n\n#include <linux/fs.h>\n\n#include <string.h>\n\nstatic char printbuf[1024];\n\nextern char *strcpy();\nextern int vsprintf();\nextern void init(void);\nextern void blk_dev_init(void);\nextern void chr_dev_init(void);\nextern void hd_init(void);\nextern void floppy_init(void);\nextern void mem_init(long start, long end);\nextern long rd_init(long mem_start, int length);\nextern long kernel_mktime(struct tm * tm);\n\nstatic int sprintf(char * str, const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\ti = vsprintf(str, fmt, args);\n\tva_end(args);\n\treturn i;\n}\n\n/*\n * This is set up by the setup-routine at boot-time\n */\n#define EXT_MEM_K (*(unsigned short *)0x90002)\n#define CON_ROWS ((*(unsigned short *)0x9000e) & 0xff)\n#define CON_COLS (((*(unsigned short *)0x9000e) & 0xff00) >> 8)\n#define DRIVE_INFO (*(struct drive_info *)0x90080)\n#define ORIG_ROOT_DEV (*(unsigned short *)0x901FC)\n#define ORIG_SWAP_DEV (*(unsigned short *)0x901FA)\n\n/*\n * Yeah, yeah, it's ugly, but I cannot find how to do this correctly\n * and this seems to work. I anybody has more info on the real-time\n * clock I'd be interested. Most of this was trial and error, and some\n * bios-listing reading. Urghh.\n */\n\n#define CMOS_READ(addr) ({ \\\noutb_p(0x80|addr,0x70); \\\ninb_p(0x71); \\\n})\n\n#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)\n\nstatic void time_init(void)\n{\n\tstruct tm time;\n\n\tdo {\n\t\ttime.tm_sec = CMOS_READ(0);\n\t\ttime.tm_min = CMOS_READ(2);\n\t\ttime.tm_hour = CMOS_READ(4);\n\t\ttime.tm_mday = CMOS_READ(7);\n\t\ttime.tm_mon = CMOS_READ(8);\n\t\ttime.tm_year = CMOS_READ(9);\n\t} while (time.tm_sec != CMOS_READ(0));\n\tBCD_TO_BIN(time.tm_sec);\n\tBCD_TO_BIN(time.tm_min);\n\tBCD_TO_BIN(time.tm_hour);\n\tBCD_TO_BIN(time.tm_mday);\n\tBCD_TO_BIN(time.tm_mon);\n\tBCD_TO_BIN(time.tm_year);\n\ttime.tm_mon--;\n\tstartup_time = kernel_mktime(&time);\n}\n\nstatic long memory_end = 0;\nstatic long buffer_memory_end = 0;\nstatic long main_memory_start = 0;\nstatic char term[32];\n\nstatic char * argv_rc[] = { \"/bin/sh\", NULL };\nstatic char * envp_rc[] = { \"HOME=/\", NULL ,NULL };\n\nstatic char * argv[] = { \"-/bin/sh\",NULL };\nstatic char * envp[] = { \"HOME=/usr/root\", NULL, NULL };\n\nstruct drive_info { char dummy[32]; } drive_info;\n\nvoid main(void)\t\t/* This really IS void, no error here. */\n{\t\t\t/* The startup routine assumes (well, ...) this */\n/*\n * Interrupts are still disabled. Do necessary setups, then\n * enable them\n */\n \tROOT_DEV = ORIG_ROOT_DEV;\n \tSWAP_DEV = ORIG_SWAP_DEV;\n\tsprintf(term, \"TERM=con%dx%d\", CON_COLS, CON_ROWS);\n\tenvp[1] = term;\t\n\tenvp_rc[1] = term;\n \tdrive_info = DRIVE_INFO;\n\tmemory_end = (1<<20) + (EXT_MEM_K<<10);\n\tmemory_end &= 0xfffff000;\n\tif (memory_end > 16*1024*1024)\n\t\tmemory_end = 16*1024*1024;\n\tif (memory_end > 12*1024*1024) \n\t\tbuffer_memory_end = 4*1024*1024;\n\telse if (memory_end > 6*1024*1024)\n\t\tbuffer_memory_end = 2*1024*1024;\n\telse\n\t\tbuffer_memory_end = 1*1024*1024;\n\tmain_memory_start = buffer_memory_end;\n#ifdef RAMDISK\n\tmain_memory_start += rd_init(main_memory_start, RAMDISK*1024);\n#endif\n\tmem_init(main_memory_start,memory_end);\n\ttrap_init();\n\tblk_dev_init();\n\tchr_dev_init();\n\ttty_init();\n\ttime_init();\n\tsched_init();\n\tbuffer_init(buffer_memory_end);\n\thd_init();\n\tfloppy_init();\n\tsti();\n\tmove_to_user_mode();\n\tif (!fork()) {\t\t/* we count on this going ok */\n\t\tinit();\n\t}\n/*\n *   NOTE!!   For any other task 'pause()' would mean we have to get a\n * signal to awaken, but task0 is the sole exception (see 'schedule()')\n * as task 0 gets activated at every idle moment (when no other tasks\n * can run). For task0 'pause()' just means we go check if some other\n * task can run, and if not we return here.\n */\n\tfor(;;)\n\t\t__asm__(\"int $0x80\"::\"a\" (__NR_pause):\"ax\");\n}\n\nstatic int printf(const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\twrite(1,printbuf,i=vsprintf(printbuf, fmt, args));\n\tva_end(args);\n\treturn i;\n}\n\nvoid init(void)\n{\n\tint pid,i;\n\n\tsetup((void *) &drive_info);\n\t(void) open(\"/dev/tty1\",O_RDWR,0);\n\t(void) dup(0);\n\t(void) dup(0);\n\tprintf(\"%d buffers = %d bytes buffer space\\n\\r\",NR_BUFFERS,\n\t\tNR_BUFFERS*BLOCK_SIZE);\n\tprintf(\"Free mem: %d bytes\\n\\r\",memory_end-main_memory_start);\n\tif (!(pid=fork())) {\n\t\tclose(0);\n\t\tif (open(\"/etc/rc\",O_RDONLY,0))\n\t\t\t_exit(1);\n\t\texecve(\"/bin/sh\",argv_rc,envp_rc);\n\t\t_exit(2);\n\t}\n\tif (pid>0)\n\t\twhile (pid != wait(&i))\n\t\t\t/* nothing */;\n\twhile (1) {\n\t\tif ((pid=fork())<0) {\n\t\t\tprintf(\"Fork failed in init\\r\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!pid) {\n\t\t\tclose(0);close(1);close(2);\n\t\t\tsetsid();\n\t\t\t(void) open(\"/dev/tty1\",O_RDWR,0);\n\t\t\t(void) dup(0);\n\t\t\t(void) dup(0);\n\t\t\t_exit(execve(\"/bin/sh\",argv,envp));\n\t\t}\n\t\twhile (1)\n\t\t\tif (pid == wait(&i))\n\t\t\t\tbreak;\n\t\tprintf(\"\\n\\rchild %d died with code %04x\\n\\r\",pid,i);\n\t\tsync();\n\t}\n\t_exit(0);\t/* NOTE! _exit, not exit() */\n}\n"
    }
  ],
  "events": {
    "BIOS": [
      {
        "id": "1",
        "event": "powerOn",
        "ram": [],
        "isCarry": false,
        "isChangeRegister": false,
        "isReadDisk": false,
        "isInterrupt": true,
        "interruptContent": "电源被按下",
        "console": "已接通电源\n",
        "moni": ""
      },
      {
        "id": "2",
        "event": "originRam",
        "ram": [
          {
            "size": "6.25%",
            "name": "BIOS",
            "addr": "0~64KB",
            "color": "black"
          },
          {
            "size": "18.75%",
            "name": "reserve memory",
            "addr": "64~256KB",
            "color": "yellow"
          },
          {
            "size": "12.5%",
            "name": "display buffer",
            "addr": "256~384KB",
            "color": "green"
          },
          {
            "size": "62.5%",
            "name": "basic memory",
            "addr": "384~1024KB",
            "color": "blue"
          }
        ],
        "isCarry": false,
        "isChangeRegister": true,
        "registers": [
          {
            "name": "PC",
            "value": "0xfffffff0"
          }
        ],
        "isReadDisk": false,
        "isInterrupt": false,
        "console": "PC设置为BIOS入口地址\n",
        "moni": ""
      },
      {
        "id": "3",
        "event": "unzip",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "62%",
            "name": "Unknown",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": true,
        "registers": [
          {
            "name": "PC",
            "value": "0"
          }
        ],
        "isReadDisk": true,
        "readPlace": "",
        "isInterrupt": false,
        "console": "将BIOS的中的中断向量表等数据解压到内存的起始位置\n",
        "moni": ""
      },
      {
        "id": "4",
        "event": "checkCMOS",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "62%",
            "name": "Unknown",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": false,
        "isReadDisk": false,
        "readPlace": "",
        "isInterrupt": true,
        "interruptContent": "检查CMOS",
        "console": "检查COMS，判断是热启动还是冷启动\n",
        "moni": ""
      },
      {
        "id": "5",
        "event": "checkTimer",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "62%",
            "name": "Unknown",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": false,
        "isReadDisk": false,
        "readPlace": "",
        "isInterrupt": true,
        "interruptContent": "Timer正常",
        "console": "检查Timer 是否正常\n",
        "moni": ""
      },
      {
        "id": "6",
        "event": "checkGcardR",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "62%",
            "name": "Unknown",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": false,
        "isReadDisk": false,
        "readPlace": "",
        "isInterrupt": true,
        "interruptContent": "显卡状态正常",
        "console": "检查显卡状态寄存器\n",
        "moni": ""
      },
      {
        "id": "7",
        "event": "displayBIOSinfo",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "62%",
            "name": "Unknown",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": false,
        "isReadDisk": false,
        "readPlace": "",
        "isInterrupt": false,
        "console": "打印BIOS信息\n",
        "moni": "Bochs BIOS build: 09/22/2016\n\n"
      },
      {
        "id": "8",
        "event": "displayBIOSinfo",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "62%",
            "name": "Unknown",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": false,
        "isReadDisk": false,
        "readPlace": "",
        "isInterrupt": true,
        "interruptContent": "键盘工作正常",
        "console": "检查键盘是否工作正常\n",
        "moni": "Press F12 to enter BIOS settings...\n\n"
      },
      {
        "id": "9",
        "event": "readBootsect",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "5%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x07C00~0x07E00",
            "color": "#808695"
          },
          {
            "size": "55%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": false,
        "isReadDisk": true,
        "readPlace": "boot",
        "isInterrupt": false,
        "console": "将bootsect读到内存中",
        "moni": ""
      }
    ],
    "bootsect": [
      {
        "id": "1",
        "event": "carryAndJump",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "5%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x07C00~0x07E00",
            "color": "#808695"
          },
          {
            "size": "35%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "0%",
            "name": "bootsect(搬运后)",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "20%",
            "name": "Unknown3",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": true,
        "carry": {
          "from": 3,
          "to": 5,
          "times": 256
        },
        "isChangeRegister": true,
        "registers": [
          {
            "name": "DS",
            "value": "0X07c0"
          },
          {
            "name": "ES",
            "value": "0x9000"
          },
          {
            "name": "ECX",
            "value": "0x00000100"
          },
          {
            "name": "EAX",
            "value": "0x00009000"
          }
        ],
        "isReadDisk": false,
        "isInterrupt": false,
        "console": "bootsect 把自己搬运到 0x90000，并跳转\n从ds:si处(物理地址0x7c00)的内容搬运到es:di(物理地址0x90000)\n搬运了256次\n每次搬运两个字节",
        "moni": ""
      },
      {
        "id": "2",
        "event": "setStackPointer",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "42%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "18%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": true,
        "registers": [
          {
            "name": "DS",
            "value": "0x9000"
          },
          {
            "name": "ES",
            "value": "0x9000"
          },
          {
            "name": "SS",
            "value": "0x9000"
          },
          {
            "name": "SP",
            "value": "0xff00"
          },
          {
            "name": "EAX",
            "value": "0x00009000"
          }
        ],
        "isReadDisk": false,
        "isInterrupt": false,
        "console": "设置ds,es,ss和sp\n设置堆栈的指针\nes:sp = 0x9000:0xff00 ，栈的设置",
        "moni": ""
      },
      {
        "id": "3",
        "event": "loadSetup",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "40%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": true,
        "registers": [
          {
            "name": "EDX",
            "value": "0x00000000"
          },
          {
            "name": "ECX",
            "value": "0x00000002"
          },
          {
            "name": "EBX",
            "value": "0x00000200"
          },
          {
            "name": "EAX",
            "value": "0x00000204"
          }
        ],
        "isReadDisk": true,
        "readPlace": "setup",
        "isInterrupt": true,
        "intdata": [
          {
            "name": "CF",
            "value": "0",
            "description": "=0，操作成功；=1，操作失败。"
          },
          {
            "name": "AH",
            "value": "0x0000",
            "description": "错误返回码。"
          },
          {
            "name": "AL",
            "value": "0x0004",
            "description": "实际读到的扇区数。"
          }
        ],
        "interruptContent": "<p>INT 13H AH=02H：读扇区</p><p>AL:要读的扇区数目，不允许使用读磁道末端以外的数值，也不允许使该寄存器为0。</p><p>DL:需要进行读操作的驱动器号，0表示软盘，80H表示硬盘。</p><p>DH:所读磁盘的磁头号。</p><p>CH:磁道号的低8位数（磁道号共10位）。</p><p>CL:低5位放入所读起始扇区号，位7-6表示磁道号的高2位。</p><p>ES:BX:读出数据的缓冲区地址。</p>",
        "console": "加载 setup 模块到 0x90200\n",
        "moni": ""
      },
      {
        "id": "4",
        "event": "getDiskParameter",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "40%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": true,
        "registers": [
          {
            "name": "EDX",
            "value": "0x00000000"
          },
          {
            "name": "EAX",
            "value": "0x00000800"
          }
        ],
        "isReadDisk": false,
        "isInterrupt": true,
        "interruptContent": "INT 13H AH=08H：读取驱动器参数",
        "intdata": [
          {
            "name": "CF",
            "value": "0x0000",
            "description": "=0，操作成功；=1，操作失败。"
          },
          {
            "name": "AH",
            "value": "0x0000",
            "description": "错误返回码"
          },
          {
            "name": "BL",
            "value": "0x0004",
            "description": "驱动器类型"
          },
          {
            "name": "CH",
            "value": "0x0009",
            "description": "最大磁道号的[7:0]"
          },
          {
            "name": "CL[7:6]",
            "value": "0x4",
            "description": "最大磁道号的[9:8]"
          },
          {
            "name": "CL[5:0]",
            "value": "0xf12",
            "description": "每磁道最大扇区数"
          },
          {
            "name": "DH",
            "value": "0x0000",
            "description": "最大磁头数"
          },
          {
            "name": "DL",
            "value": "0x0102",
            "description": "驱动器数量"
          },
          {
            "name": "ES:DI",
            "value": "0xf000:0xefde",
            "description": "指向软驱磁盘参数表"
          }
        ],
        "console": "获得磁盘驱动器参数（主要是每磁道的扇区数量）\n",
        "moni": ""
      },
      {
        "id": "5",
        "event": "printLoading",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "40%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": true,
        "registers": [
          {
            "name": "ECX",
            "value": "0x00000018"
          },
          {
            "name": "EBX",
            "value": "0x00000007"
          },
          {
            "name": "EAX",
            "value": "0x00001301"
          }
        ],
        "isReadDisk": false,
        "isInterrupt": true,
        "intdata": [
          {
            "name": "CH",
            "value": "0x0009",
            "description": "行扫描开始"
          },
          {
            "name": "CL",
            "value": "0x0607",
            "description": "行扫描结束"
          },
          {
            "name": "DH",
            "value": "0x0000",
            "description": "行号"
          },
          {
            "name": "DL",
            "value": "0x0004",
            "description": "列号"
          }
        ],
        "interruptContent": "<p>INT 10H AH=03H：获取光标位置和形状</p><p>AH:=03H,读光标的位置</p><p>BH:页号</p><p>INT 10H AH=13H：在Teletype模式下显示字符串</p><p>AH:＝13H，在Teletype模式下显示字符串</p><p>BH:页码</p><p>页码:属性（若 AL=00H 或 01H）</p><p>CX:要显示的字符串的长度</p><p>DH、DL:坐标（行、列）</p><p>ES:BP:指向要显示的字符串</p><p>AL:显示输出方式</p>",
        "console": "打印 “Loading system …”\n",
        "moni": "Loading system …\n"
      },
      {
        "id": "6",
        "event": "loadSystem",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "5%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "20%",
            "name": "system",
            "addr": "0x10000~",
            "color": "#19BE6B"
          },
          {
            "size": "15%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown3",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": true,
        "registers": [
          {
            "name": "ES",
            "value": "0x1000"
          },
          {
            "name": "EAX",
            "value": "0x00001000"
          }
        ],
        "isReadDisk": true,
        "readPlace": "system",
        "isInterrupt": false,
        "console": "加载 system 到 0x10000”\n",
        "moni": ""
      }
    ],
    "setup": [
      {
        "id": "1",
        "event": "keepCursor",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "5%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "20%",
            "name": "system",
            "addr": "0x10000~",
            "color": "#19BE6B"
          },
          {
            "size": "15%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown3",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": true,
        "registers": [
          {
            "name": "EBX",
            "value": "0x00000000"
          },
          {
            "name": "EAX",
            "value": "0x00000300"
          },
          {
            "name": "DS",
            "value": "0x9000"
          }
        ],
        "isReadDisk": false,
        "isInterrupt": true,
        "intdata": [
          {
            "name": "DH",
            "value": "0x0000",
            "description": "行号"
          },
          {
            "name": "DL",
            "value": "0x1500",
            "description": "列号"
          }
        ],
        "interruptContent": "<p>INT 10H AH=03H：获取光标位置和形状</p><p>AH:=03H,读光标的位置</p><p>BH:页号</p>",
        "console": "保存光标的位置\n",
        "moni": ""
      },
      {
        "id": "2",
        "event": "keepExpandRam",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "5%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "20%",
            "name": "system",
            "addr": "0x10000~",
            "color": "#19BE6B"
          },
          {
            "size": "15%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown3",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": true,
        "registers": [
          {
            "name": "EAX",
            "value": "0x00008800"
          }
        ],
        "isReadDisk": false,
        "isInterrupt": true,
        "intdata": [
          {
            "name": "AX",
            "value": "0x3c00",
            "description": "从1M处开始的扩展内存大小"
          }
        ],
        "interruptContent": "<p>INT 15H AH=88H：获取从 1M 处开始的扩展内存大小</p><p>AH:=88H,取系统所含扩展内存大小，并保存在内存 0x90002 处</p>",
        "console": "获取从 1M 处开始的扩展内存大小\n",
        "moni": ""
      },
      {
        "id": "3",
        "event": "getDisplayMode",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "5%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "20%",
            "name": "system",
            "addr": "0x10000~",
            "color": "#19BE6B"
          },
          {
            "size": "15%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown3",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": true,
        "registers": [
          {
            "name": "EAX",
            "value": "0x00000f00"
          }
        ],
        "isReadDisk": false,
        "isInterrupt": true,
        "intdata": [
          {
            "name": "AH",
            "value": "0x50",
            "description": "字符列数"
          },
          {
            "name": "AL",
            "value": "0x03",
            "description": "显示模式"
          },
          {
            "name": "BH",
            "value": "0x00",
            "description": "当前显示页"
          }
        ],
        "interruptContent": "<p>INT 10H AH=0FH：获取显示卡当前的显示模式</p><p>AH:=0FH,获取显示卡当前的显示模式</p>",
        "console": "获取显示卡当前的显示模式\n",
        "moni": ""
      },
      {
        "id": "4",
        "event": "loadSystem",
        "ram": [
          {
            "size": "1%",
            "name": "中断向量表",
            "addr": "0x00000~0x00400",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "BIOS数据区",
            "addr": "0x00400~0x00500",
            "color": "#FDE74C"
          },
          {
            "size": "5%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "20%",
            "name": "system",
            "addr": "0x10000~",
            "color": "#19BE6B"
          },
          {
            "size": "15%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown3",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": false,
        "isReadDisk": false,
        "isInterrupt": true,
        "interruptContent": "关中断",
        "console": "关中断",
        "moni": ""
      },
      {
        "id": "5",
        "event": "carrySystem",
        "ram": [
          {
            "size": "0%",
            "name": "System(搬运后)",
            "addr": "0x00000~",
            "color": "#19BE6B"
          },
          {
            "size": "7%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "20%",
            "name": "system",
            "addr": "0x10000~",
            "color": "#19BE6B"
          },
          {
            "size": "15%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown3",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": true,
        "carry": {
          "from": 2,
          "to": 0,
          "times": 256
        },
        "isChangeRegister": true,
        "registers": [
          {
            "name": "DS",
            "value": "0X2000"
          },
          {
            "name": "ES",
            "value": "0x1000"
          },
          {
            "name": "ECX",
            "value": "0x00008000"
          },
          {
            "name": "EAX",
            "value": "0x00001000"
          }
        ],
        "isReadDisk": false,
        "isInterrupt": false,
        "console": "移动 system 模块到 0x00000\n",
        "moni": ""
      },
      {
        "id": "6",
        "event": "loadIDT",
        "ram": [
          {
            "size": "20%",
            "name": "System",
            "addr": "0x00000~",
            "color": "#19BE6B"
          },
          {
            "size": "22%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": true,
        "registers": [
          {
            "name": "DS",
            "value": "0x9020"
          },
          {
            "name": "EAX",
            "value": "0x00009020"
          }
        ],
        "isReadDisk": false,
        "isInterrupt": true,
        "interruptContent": "加载IDT(中断描述表)",
        "console": "加载IDT(中断描述表)",
        "moni": ""
      },
      {
        "id": "7",
        "event": "loadGDT",
        "ram": [
          {
            "size": "20%",
            "name": "System",
            "addr": "0x00000~",
            "color": "#19BE6B"
          },
          {
            "size": "22%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": false,
        "isReadDisk": false,
        "isInterrupt": true,
        "interruptContent": "加载GDT(全局描述符表)",
        "console": "加载GDT(全局描述符表)",
        "moni": ""
      },
      {
        "id": "7",
        "event": "openA20",
        "ram": [
          {
            "size": "20%",
            "name": "System",
            "addr": "0x00000~",
            "color": "#19BE6B"
          },
          {
            "size": "22%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": false,
        "isReadDisk": false,
        "isInterrupt": true,
        "interruptContent": "<p>开启A20</p><p>通过8042 P2 PORT</p>",
        "console": "开启A20，扩大寻址能力",
        "moni": ""
      },
      {
        "id": "7",
        "event": "enterProtectMode",
        "ram": [
          {
            "size": "20%",
            "name": "System",
            "addr": "0x00000~",
            "color": "#19BE6B"
          },
          {
            "size": "22%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": true,
        "registers": [
          {
            "name": "EAX",
            "value": "0x00009020"
          }
        ],
        "isReadDisk": false,
        "isInterrupt": true,
        "interruptContent": "保护模式已进入",
        "console": "保护模式已进入",
        "moni": ""
      }
    ],
    "head": [
      {
        "id": "1",
        "event": "beginPaging",
        "ram": [
          {
            "size": "1%",
            "name": "页表1",
            "addr": "0x1000~0x2000",
            "color": "#2D3047"
          },
          {
            "size": "1%",
            "name": "页表2",
            "addr": "0x2000~0x3000",
            "color": "#BB8C44"
          },
          {
            "size": "1%",
            "name": "页表3",
            "addr": "0x3000~0x4000",
            "color": "#FF9B71"
          },
          {
            "size": "1%",
            "name": "页表4",
            "addr": "0x4000~0x5000",
            "color": "#E84855"
          },
          {
            "size": "16%",
            "name": "System",
            "addr": "0x00000~",
            "color": "#19BE6B"
          },
          {
            "size": "22%",
            "name": "Unknown1",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "2%",
            "name": "bootsect",
            "addr": "0x90000~0x90200",
            "color": "#808695"
          },
          {
            "size": "8%",
            "name": "setup",
            "addr": "0x90200~0x90A00",
            "color": "#2D8CF0"
          },
          {
            "size": "12%",
            "name": "Unknown2",
            "addr": "",
            "color": "#B2EBF2"
          },
          {
            "size": "10%",
            "name": "显示缓冲区",
            "addr": "0xA0000~0xC0000",
            "color": "#FA7921"
          },
          {
            "size": "13%",
            "name": "DEVICE",
            "addr": "0xC0000~0xF0000",
            "color": "#E91E63"
          },
          {
            "size": "13%",
            "name": "ROM BIOS映射区",
            "addr": "0xF0000~0x100000",
            "color": "#673AB7"
          }
        ],
        "isCarry": false,
        "isChangeRegister": false,
        "isReadDisk": false,
        "isInterrupt": true,
        "interruptContent": "开启分页，设置了5个页表",
        "console": "开启分页，跳转到 main()",
        "moni": ""
      }
    ]
  }
}
